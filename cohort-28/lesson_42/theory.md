# Списки

* Список - определенный тип коллекции (контейнера). Некоторая сущность, которая может хранить набор объектов различного типа.
* Важной особенностью списка является то, что его элементы можно получать по индексу (порядковый номер), прям как в массиве.
* Список, как правило, определяется набором операций, который можно выполнять над этим списком.

* Что это за набор операций?

```
- получение размера списка
- проверка на пустоту
- проверить, есть ли какой-либо элемент в списке
- очистить список
- добавить элемент в список
- удалить элемент из списка
- добавить по индексу элемент
- получить элемент по индексу
- узнать индекс какого-либо элемента (первый, если таких несколько)
- узнать индекс элемента, но последний (если таких элементов несколько)
- удалить элемент из списка по индексу
- заменить элемент по индексу (убрать старый и вместо него записать новый)
```

* У нас есть набор действий, и общее понимание того, как это должно работать.
* Но пока мы не знаем, как именно следует написать наш список.
* Воспользуемся интерфейсами!
* Интерфейс - это просто набор операций, без конкретной реализации. Он позволит нам сформировать общее представление о том, что мы хотим сделать
* И, возможно, заложить некоторую "реализацию"

## Дополнительно

* `default` - метод, для которого мы указываем реализацию прямо в интерфейсе. Это бывает удобно, если этот метод основывается на использовании других методов.
* Если вы заметили, то некоторые методы имеют в качестве аргумента параметр типа E, а некоторые Object, почему так?
* Мы хотим соблюсти гарантию, что все элементы списка - одинаковые.
* Поэтому операции добавления имеют параметр E (в список продуктов нельзя добавить трактор)
* Но, мы не хотим совсем сильно ограничивать пользователей нашего списка
* Поэтому те операции, которые не подразумевают добавление новых элементов (например это операции удаления или поиска) мы делаем через Object
* Не страшно, если человек захочет удалить трактор из списка продуктов (даже если его там нет)
* Не страшно, если человек захочет получить номер трактора из списка продуктов (даже если его там нет)
* Пример реального использования:
    * Вам приходят объекты совершенно разных типов (от жены), вы естественно будете добавлять их в разные списки (используем E)
    * Потом, жена будет проверять, а все ли вы купили? Вы будете искать все объекты во всех списках (и да, трактор в списке продуктов тоже)

## Встроенный ArrayList и интерфейс List

* Мы с вами пишем собственную реализацию коллекций, для того, чтобы лучше понимать, как они работают
* Также, мы понимаем, что реализовать список можно по-разному (например, через массив)
* Встроенная реализация `ArrayList` работает через массив.
* По сути, ArrayList - это просто обертка, набор методов и проверок вокруг обычного массива.
* Почему именно в полтора раза?
    * Здесь применяют правило:
        * Если массив заполнен на 100 элементов, то он с бОльшей вероятностью будет заполнен на 150, а не на 200

## Итератор

![image](https://raw.githubusercontent.com/ait-tr/cohort28/main/basic_programming/lesson_42/img/1.png)

* Зачастую нам необходимо решить задачу последовательного обхода какой-либо коллекции.
* Это значит, что на каждом шаге нужно получать один новый элемент из коллекции и что-то с ним делать.
* Например:
    * Распечатать все элементы какой-либо коллекции
    * Изменить какие-либо данные в объектах коллекции (всем пользователям из списка изменить статус оплаты больничного)
* Такие задачи можно решать с помощью обычного цикла for.
* Но, не ко всем коллекциям можно применить такой цикл, потому что там просто нет индексов.
* Какие это коллекции не подразумевает наличие индексов?
* Например, `HashSet` - множество, не допускает дубликатов, не гарантирует какие-либо индексы (их там вообще нет)
* Поэтому обычный цикл for к нему не применим, но при этом у нас могут быть задачи на перебор элементов
* Как эту проблему решили в Java? Придумали концепцию итераторов.
* Итератор - это некоторый объект, который "знает" как обходить коллекцию и "умеет" обходить коллекцию.
* Каждая коллекция сама должна реализовать эту концепцию, потому что кроме коллекции никто не может получить доступ к ее внутренней структуре.
* Вопрос, а как итератор выглядит в Java? В Java итератор это интерфейс:

```
public interface Iterator<E> {
  boolean hasNext(); // проверяет, есть ли следующий элемент?
  E next(); // возвращает новый элемент из коллекции
```
* Каждая коллекция должна реализовать этот интерфейс "Iterator"
* Как гарантировать тот факт, что у коллекции точно есть итератор?
* Для этого вводят понятие интерфейса "Iterable" (итерируемый). Если коллекция может предоставить итератор, то она должна реализовать этот интерфейс

```
public interface Iterable<T> {
  Iterator<T> iterator();
}
```

* Данный интерфейс содержит один метод, который возвращает итератор.
* Получается, что и `ArrayList` и `HashSet` имеют метод `iterator()` в котором как раз реализован итератор для соответствующей коллекции

* Также, если ваша коллекция предоставляет итератор (т.е. она Iterable), то можно применить цикл `for-each`

```
for (String word : words) {
   System.out.println(word);
}
```

* `word` - переменная, которая на каждой итерации цикла принимает новое значение - новый элемент из коллекции
* `words` - название коллекции, которую мы хотим "обойти"

![image](https://raw.githubusercontent.com/ait-tr/cohort28/main/basic_programming/lesson_42/img/2.png)

## Словарик

* `size` - размер
* `empty` - пустой

## Дальнейшие темы

* `Enum` - разбор конкретных задач
* `Exceptions` - пример Best Practices